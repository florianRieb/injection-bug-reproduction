package de.netzebw;

import static de.netzebw.DynamoDBResource.createTableRequest;
import static de.netzebw.DynamoDBResource.deleteTableRequest;
import static java.lang.Boolean.FALSE;
import static org.apache.commons.lang3.StringUtils.isNotEmpty;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;

import com.google.common.collect.ImmutableMap;

import de.netzebw.util.entity.StaticMessageTable;
import de.netzebw.util.to.Message;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.BatchWriteItemRequest;
import software.amazon.awssdk.services.dynamodb.model.BatchWriteItemResponse;
import software.amazon.awssdk.services.dynamodb.model.CreateTableRequest;
import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;
import software.amazon.awssdk.services.dynamodb.model.ListTablesResponse;
import software.amazon.awssdk.services.dynamodb.model.WriteRequest;

/**
 * The Class MessageProcessingTestHelper.
 * Provides methods to fill and check the dynamoDB.
 * Also holds the message objects for unit tests.
 *
 * @author Florian Riebandt, CGI
 * @version 0.0.1
 * @since
 */

@Slf4j
@UtilityClass
public class MessageProcessingTestHelper {

  private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

  public static final String TABLE_NAME = "Message";

  public static final Message MESSAGE_01 =
      Message.builder().uuid(UUID.randomUUID().toString()).city("Stuttgart").functionalId("00000001")
          .reportingTimestamp(Objects.toString(LocalDateTime.now())).build();

  public static final Message MESSAGE_02 =
      Message.builder().uuid(UUID.randomUUID().toString()).city("Ludwigsburg").functionalId("00000002")
          .reportingTimestamp(Objects.toString(LocalDateTime.parse("2020-06-22 12:30", FORMATTER))).build();

  public static void createTableIfNotExists(final DynamoDbClient dynamoDb) {
    final CreateTableRequest createTableRequest = createTableRequest();
    if (existsTable(dynamoDb, createTableRequest.tableName())) {
      return;
    }
    dynamoDb.createTable(createTableRequest());
  }

  public static void deleteTableIfExists(final DynamoDbClient dynamoDb) {
    final DeleteTableRequest deleteTableRequest = deleteTableRequest();
    if (!existsTable(dynamoDb, deleteTableRequest.tableName())) {
      return;
    }
    dynamoDb.deleteTable(deleteTableRequest());
  }

  public static void fillTable(final DynamoDbClient dynamoDb,

      final Collection<Message> messages) {
    log.info("put request {} ", messages.toString());

    final List<WriteRequest> requestList = messages.stream()
        .map(msg -> Message.fromItemToMap(msg))
        .map(map -> WriteRequest.builder().putRequest(r -> r.item(map).build()).build())
        .collect(Collectors.toList());

    final BatchWriteItemRequest batchRequest =
        BatchWriteItemRequest.builder().requestItems(ImmutableMap.of(StaticMessageTable.MESSAGE_TABLE_NAME, requestList)).build();

    final BatchWriteItemResponse resp = dynamoDb.batchWriteItem(batchRequest);
    log.info("resp metadata {}", resp.responseMetadata().toString());

  }

  private static boolean existsTable(final DynamoDbClient dynamoDb, final String tableName) {
    if (null == dynamoDb) {
      return FALSE;
    }
    final ListTablesResponse listTableResponse = dynamoDb.listTables();
    return isNotEmpty(tableName) && null != listTableResponse && null != listTableResponse.tableNames() && !listTableResponse.tableNames().isEmpty()
        && listTableResponse.tableNames().stream().anyMatch(tableName::equals);
  }

}
